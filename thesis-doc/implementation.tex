\chapter{Implementation}
\label{ch:Implementation}
This chapter describes the implementation details of the prototype, as well as the analysis of the data collected from the studies.
To implement the prototype, Arduino software was developed that measures temperature sensor values and IMU data and saves them to a microSD card along with a timestamp.
Implementation details for evaluating and analyzing the collected data are then described.

\section{Prototype}
The prototype is controlled by OpenEarable, which has been programmed to be controlled via Arduino code. An Arduino Nano33 BLE is built into the OpenEarable, which makes this customization easy. The main task of the prototype is to collect data from the temperature sensors and an IMU and store them in a CSV file on the SD card, which has a dedicated slot in the OpenEarable. Similarly to conventional Arduino code, the prototype's code consists of a \texttt{setup()} and a \texttt{loop()} method.

In the \texttt{setup()} method, all the required components are initialized. This includes the sensors, the IMU, the SD card logger, and the button interrupt. The latter is used to ensure that a measurement is terminated within two seconds if a button is pressed twice. When the sensors are initialized, a \texttt{Wire} connection is established and the multiplexer is triggered. The multiplexer is crucial when reading out the sensors, as each sensor is read out in the same way, but before that, the multiplexer is triggered to enable access to the next sensor. The multiplexer makes it possible that always only one of the 8 possible ports is free for reading. Thus each access is opened once and the sensor is initialized.

In addition to the regular operations in the \texttt{loop()} method, the code contains functionality for handling key presses. A key press is detected using an interrupt. As soon as the key is pressed, a function is started that checks whether the key has already been pressed within the last two seconds. If so, the data acquisition of sensor data and IMU data is stopped and the SD card with the collected data is written.

One of the main tasks is to read data from the MLX90632 sensors and the IMU sensor. For each temperature sensor, the code selects the appropriate I2C channel through the multiplexer and retrieves the temperature readings through the modified "Protocentral\_MLX90632" library. The library has been heavily modified to allow parallel measurement of the IMU data. The IMU sensor, which is built directly into the OpenEarable, provides accelerometer, gyroscope, and magnetometer data.

The collected data from one pass of the \texttt{loop()} function is then written to the SD card. Each line represents one run of the \texttt{loop()} function and contains the 6 temperature sensor values and the 9 IMU data as well as a time value and an ID.

In addition, the "Protocentral\_MLX90632" library has been adapted to allow parallel measurement of IMU data. In the original library, the \texttt{getObjectTemp()} function waits for the temperature value to become available by waiting in a \texttt{while} loop for a register value to be set indicating newly available data. This resulted in an unacceptably long wait time, as the total wait time for all 6 sensors was three seconds at a refresh rate of 2 Hz. During this time, no IMU data signal could be read because the Arduino Nano33 BLE does not allow for parallelism. To address this issue, the check, if new data is available, will be ignored. 
Instead, the temperature value is read out in each loop iteration. 
This leads to the fact that the temperature value may not have updated yet. 
However, the sampling rate is so high that this does not affect the final result.

\section{Sensor Calibration Implementation in Arduino}
The calibration was implemented using the Arduino platform, where the library for the MLX90632 sensors was modified to introduce an emissivity factor of $0.98$ as per the sensor datasheet. This value is optimized for human body temperature measurement and was also used for the metal plate during calibration. This emissivity factor allows the system to account for the natural variability in thermal radiation between different materials and provides a standardized reading that is consistent across different environments.

\section{After data analyzation: Python stuff}